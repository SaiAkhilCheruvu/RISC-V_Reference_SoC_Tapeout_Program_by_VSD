
# Day 1

Welcome to Day 1 of the RTL Workshop. In this session, we focused on understanding the fundamentals of Verilog RTL design and synthesis. We started by working on a 2:1 multiplexer module, simulating its behavior using iverilog, and analyzing the signal waveforms in GTKWave to verify functionality. Next, we explored the synthesis process using Yosys, generating gate-level netlists compatible with the Sky130 PDK.

This hands-on experience laid a strong foundation in digital design workflows, from writing RTL code and running simulations to synthesizing designs using open-source tools.

Let's now proceed to review the detailed contents covered during this session.

## What is Design?

A design refers to the Verilog code or a collection of Verilog codes created to perform a specific intended functionality according to required specifications.

## What is a Testbench?

A testbench is a setup that applies stimulus (test vectors) to the design in order to verify and check its functionality. It doesn't have primary inputs or outputs.

![tb](https://github.com/user-attachments/assets/b2515679-8ac4-42a5-921f-86af7aa000df)


This diagram shows the testbench setup with stimulus generation, design under test, and output observation. The design has primary inputs and outputs, while the testbench itself does not.

## What is a Simulator?


A simulator is a tool used to check if the RTL design adheres to the specification by simulating the behavior of the design.

### How does a Simulator work?

-> The simulator monitors the input signals for any changes.

-> Whenever there is a change on the input, the output is evaluated accordingly. If there is no change to the input, there is no change to the output.

Essentially, the simulator continuously checks for changes in the input values and updates the outputs in response.

## Iverilog

Iverilog is an open-source compiler that translates Verilog HDL code into executable simulation programs. It compiles the Verilog source along with a testbench into a simulation file, which can be run to verify the design behavior before actual hardware implementation.

## GTKWave

GTKWave is an open-source waveform viewer used to visualize simulation output waveforms. It reads Value Change Dump (VCD) files generated by simulators like iverilog and displays signal transitions over time, helping to analyze and debug the design.

## Iverilog Based Simulation Flow

Iverilog compiles the design and testbench into an executable simulation file. Running this file produces a VCD (Value Change Dump) waveform file. GTKWave then reads the VCD file to display the signal waveforms, allowing verification of the design’s behavior.


![sf](https://github.com/user-attachments/assets/05d34801-bb81-47a3-80b2-2032a5b181dd)

## Lab Setup and File Structure

1. Open terminal and switch to root user:
   
   ```
   sudo -i
   ```
2. Navigate to the working directory using the following commands:
   
   ```
   cd /home
   cd vsd
   cd VLSI
   cd vsdflow
   ```

3. Clone the workshop repository:
   
   ```
   git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git
   ```
4. Go to the cloned directory:

   ```
   cd sky130RTLDesignAndSynthesisWorkshop
   ```
5. Explore the standard cell library and models:
   
   ```
   cd my_lib
   ```
   Here you will find lib (standard cell library) and verilog_model (Verilog models of the standard cells).

6. Go back to the cloned repository directory and access the Verilog source files and testbenches by using:

   ```
   cd verilog_files
   ```

## Simulating and Analyzing a 2:1 Multiplexer

1. Change to the verilog_files directory and compile the design and testbench:

   ```
   iverilog good_mux.v tb_good_mux.v
   ```

2. Execute the generated simulation binary to produce a VCD waveform file:

   ```
   ./a.out
   ```

3. Open the VCD file with GTKWave to view signal transitions:

   ```
   gtkwave tb_good_mux.vcd
   ```

Once GTKWave loads, drag and drop the inputs and outputs under the “Signals” window, then click "Fit to Screen" to assess the output waveform visually.


4. To review and edit the Verilog source and testbench files side-by-side, in the terminal run:

   ```
   gvim tb_good_mux.v -o good_mux.v
   ```

#### good_mux Module:

This module implements a simple 2:1 multiplexer. Given two data inputs (i0, i1) and a select line (sel), the output y is assigned i1 if sel is high, and i0 otherwise. The core logic uses an always block to update y depending on the value of sel.

```
module good_mux (input i0, input i1, input sel, output reg y);
always @ (*)
begin
    if(sel)
        y <= i1;
    else 
        y <= i0;
end
endmodule
```
#### Testbench (tb_good_mux):

This testbench initializes all inputs to 0 and uses three always blocks to toggle sel every 75 time units, i0 every 10 units, and i1 every 55 units. The $dumpfile and $dumpvars commands enable waveform generation for GTKWave. The simulation ends after 300 time units. These delays help systematically test the multiplexer by changing inputs at different intervals, making it easy to observe and verify the output behavior in the waveform viewer.

```
module tb_good_mux;
    reg sel, i0, i1;
    wire y;

    // Instantiate the multiplexer
    good_mux uut (
        .i0(i0),
        .i1(i1),
        .sel(sel),
        .y(y)
    );

    initial begin
        $dumpfile("tb_good_mux.vcd"); // For waveform viewing
        $dumpvars(0, tb_good_mux);
        sel = 0; i0 = 0; i1 = 0;
        #300 $finish;
    end

    always #75 sel = ~sel;
    always #10 i0 = ~i0;
    always #55 i1 = ~i1;
endmodule
```

## What is a Synthesizer?

A synthesizer in digital design is a tool that converts high-level hardware descriptions, like Verilog RTL code, into a gate-level netlist made up of logic gates and flip-flops, enabling the design to be implemented on actual hardware. In this workshop, we use Yosys as our synthesizer—an open-source Verilog HDL synthesis tool that reads Verilog code and generates RTL or gate-level representations of the design. 

*Yosys* is widely used in both academic and industry settings for mapping Verilog designs to ASICs or FPGAs, and it supports a broad range of synthesis tasks, making it a flexible and accessible choice for digital circuit synthesis.

### Verifying the Synthesis

This diagram shows how to verify a synthesized digital design by simulating the generated netlist alongside a testbench. Both the netlist (resulting from synthesis) and testbench code are fed into iverilog, which produces a VCD (Value Change Dump) file. The VCD file captures all signal transitions during simulation. Finally, GTKWave is used to visualize these transitions, making it easy to check whether the synthesized circuit behaves as expected.

![y1](https://github.com/user-attachments/assets/281dd8c7-c099-409f-997a-36dba921686a)

### Yosys Setup

This diagram outlines the basic Yosys synthesis flow. The design's Verilog code and the technology library file (.lib) are both provided as inputs to Yosys. Through commands like read_verilog (to read the design) and read_liberty (to import cell information), Yosys processes the design and produces a gate-level netlist file using write_verilog. This gate-level netlist can then be used in further simulation or for physical implementation.

![y2](https://github.com/user-attachments/assets/eec42565-0f93-4942-b264-7d13c133aa76)

   
## Why Do Libraries Have Different Gate "Flavors"?

A ```.lib``` file contains many versions of each logic gate (like AND, OR, NOT), each with different properties to help optimize digital circuits for speed, power, area, and reliability. Synthesis tools automatically select the best gate flavor for each part of your design, balancing these trade-offs to meet your specific requirements.

*Propagation delay:* The time it takes for a signal to travel from a gate's input to its output after a change.

*Combinational delay:* The total propagation delay through a path of logic gates between two sequential elements.

*Setup time:* The minimum time before a clock edge that an input must be stable for correct data capture by a flip-flop.

*Hold time:* The minimum time after a clock edge that an input must remain stable to ensure proper operation.

We need both fast and slow cells because using only fast gates everywhere would increase power consumption and chip area, and could cause timing or noise issues. Slow cells are more efficient for non-critical paths, while fast cells are used where speed is essential. This mix allows synthesis tools to optimize the design for performance, power, and area.

Faster cells have wider transistors that can charge and discharge load capacitance more quickly, reducing delay but increasing area and power consumption; slower cells use narrower transistors, saving area and power but with longer delay, so using a mix allows optimization of speed, power, and chip size efficiently.

## Yosys Logic Synthesis





